---
layout: post
title: Mathematical Explanation<br/>
       Variational Auto-Encoder
intro: This article was created for those who would like to understand more about the mathematical reasoning behind a model such as VAE. For this purpose I am introducing a range of different concepts ...

start: This article was created for those who would like to understand more about the mathematical reasoning behind a model such as VAE. For this purpose I am introducing a range of different concepts in statistics that help understand the decision-making of this paper's authors. I sum- marized only the most relevant mathematical statements for this post of each topic. To make a VAE more comprehensive I emphasized 
  on the modeling of it and core concepts to computationally realize it. Aditionally, I used day-to-day examples and visualisations that help building an intuition. If you have any questions or suggestions  regarding this topic feel free to contact me.

chapters: ["Introduction",
           "Modeling",
           "Bayesian inference",
           "The VAE architecture",
           "Variational inference",
           "The Evidence Lower Bound",
           "Monte Carlo Estimate",
           "Reparameterization Trick",
           "Sources"]
---

<br/>

### Required knowledge

The following topics are necessary to understand this article:
- Basic probability theory
- Basic statistics

I will recap some necessary core concepts from the following topics:
- MLE, MAP estimator & EM
- Bayesian inference
- Variational inference
- Monte Carlo Estimate

If you are keen to know more details about each topic I can suggest: 
- [Introduction to Mathematical Statistics by Hogg](https://minerva.it.manchester.ac.uk/~saralees/statbook2.pdf) 
- [Mathematical Statistics by van de Geer](https://www.stat.math.ethz.ch/~geer/mathstat.pdf) 
- [Monte Carlo Methods by Kroese](https://people.smp.uq.edu.au/DirkKroese/mccourse.pdf)

<br/>

![_config.yml]({{ site.baseurl }}/images/separator.png)

{% include chapter.html name="Introduction" %}

To understand the architecture of a VAE, a generator, and its mathematical model, we will need to determine first the goal of such a model type and its 
relationship to a discriminator. <br/>
With a discriminative model we want to make a prediction about an attribute based on various observations. Such a model tries to learn the mapping from that data 
to this attribute. To do so it tries to find features of these observations that has the highest correlation with that attribute.
But correlation is not causation. Imagine, when I was a little child, I always got upset when my mom bought apples that had some brown spots.
She always answered: "No, they are good! Those are just some injuries." 
Sure, as if apples are like humans and could have "injuries" - you are just trying to make these cheap apples palatable, was my response back then.
Indeed, my mom was right, injuries of the apples skin exposes its tissue to oxygen that turns polyphenol (a micronutrient in the apple) into melanin. 

Coming back to our problem, we could collect observations, like skin color of an apple and its surface structure and so on, to make a prediction whether an apple is rotten or not.
And, even though my mom was right, brown spots are usually a good indication since some infecting spores of fungi that occur in rotten apples create a brown coloration.
A discriminator would be able to find that correlation, like me as a child. 

<br/> Unfortunately, such a model will eliminate also apples that are healthy to consume but just had an injury. You could argue now, that the correlation 
between the browning of apples and its decay cannot be that high compared to the correlation between the wrinkling of skin and the level of decay.
So we simply take the latter feature to make such a prediction. Though, if we have a dataset where every brown apple is also rotten we couldn't 
differentiate between the relevance of those two features. And typically we choose to build such models to make predictions that we cannot do by our-self, hence, in a realistic problem 
we wouldn't have that knowledge.
Because of those instances, a model that can learn the causal relationship is of course more precise. 
To achieve that it would have to learn the generating process of rotten apples. 

If we abstract this case, we could say that an attribute like the level of decay is just another feature that describes an object.
From that perspective every object is a state of a collection of features or call it attributes if you like.

That would mean that an example of an apple is an expression of the following states:
- mainly red colored
- brown spots
- smooth skin
- *decomposed*
- etc.

Then a trained generator would tell us that the occurrence of all these features' states at the same time is very unrealistic.
In other words, a generator should uncover **how all the features that describe an object are jointly distributed**.
<br/>

Another important goal of training a generator is data completion. For instance, image resolution. For this purpose we need to transform the generator in a conditional generator.
It generates data depending on the state of some additional data, here a low-resolution image.

<br/>

In summary, such a model should be used for semi-supervised learning, data completion and generating realistic data. And it does so by learning
the joint distribution of all features.

![_config.yml]({{ site.baseurl }}/images/separator.png)

<br/>


{% include chapter.html name="Modeling" %}

<ins>*REMARK*:</ins> I usually use capital letters to denote random variables or vectors and *f* to denote probability density functions compared to *p* for 
probability mass functions. Since the authors of the VAE paper chose to use small letters for random vectors and *p* for both probability density and mass 
function I decided to stick with their notation.

<br/>

Some of you may know that finding a proper data representation, that includes extracting relevant features of the data, will increase the chances 
of training a good discriminator. Typical methods include the use of an auto-encoder or principal component analysis since such a representation is more expressive.
A new representation of a datapoint is called latent feature vector. The word, latent, stems from the fact that the space of latent features in a DL model for 
data representation is hidden from us. In my apple example from before we could say that the level of decay is also a latent feature.

<br/>

Let's first formulate that mathematically:

![_config.yml]({{ site.baseurl }}/images/2023-7-6-VAE/eq1.png)

<br/>

Next, we want to build a neural network that approximates this joint distribution.
To achieve this I want to introduce the concept of a Bayesian Belief Network:

A Bayesian Belief Network is a directed acyclic graph where each node is a random variable and the edges (arcs) are the densities. It is useful to display the conditional
relationships between each random variables.

<br/>

![_config.yml]({{ site.baseurl }}/images/2023-7-6-VAE/eq2.png)

<br/>

![_config.yml]({{ site.baseurl }}/images/separator.png)

<br/>

{% include chapter.html name="Bayesian inference" %}

<br/>

Since we do not know the pdf of the latent variables but might have some prior knowledge we can use Bayesian inference to update our prior belief by the posterior.

![_config.yml]({{ site.baseurl }}/images/2023-7-6-VAE/eq4.png)

<br/>
This principle will set up the architecture and mechanism of a VAE.
<br/>

![_config.yml]({{ site.baseurl }}/images/separator.png)

<br/>

{% include chapter.html name="The VAE architecture" %}

<br/>

To obtain the likelihood a neural network learns its distribution during training while we need to assign another neural network with the task
to learn the distribution of the posterior. The latter type of neural network is called an inference model. For this purpose, the Variational Auto-Encoder
uses an encoder to parametrize the posterior and a decoder to parametrize the likelihood.

The following illustration captures this mechanism:

{% include image.html url="/images/2023-7-6-VAE/diag1.png" text="This diagram illustrates assignments of distributions." %}

<br/>

To understand the learning process for this model I will need to introduce you to the concept of a family of distributions:

![_config.yml]({{ site.baseurl }}/images/2023-7-6-VAE/eq5.png)

For unsupervised and semi-supervised learning the authors of this paper suggest to assume a multivariate Gaussian. Since a multivariate normal distribution has a mean vector and a diagonal covariance 
matrix as its parameters the inference model, here an encoder, has to define them to describe the posterior. 

{% include image.html url="/images/2023-7-6-VAE/vae_arch.png" text="An explanatory illustration that shows the model design." %}

<br/>

![_config.yml]({{ site.baseurl }}/images/separator.png)

<br/>

{% include chapter.html name="Loss function" %}

<br/>
Both models learn the parameters via an update algorithm that searches a minimizer of a chosen objective, i.e. loss function. 
A typical objective would be Maximum A Posterior or Maximum Likelihood function to infer the best parameter for our model.

![_config.yml]({{ site.baseurl }}/images/2023-7-6-VAE/eq7.png)

![_config.yml]({{ site.baseurl }}/images/2023-7-6-VAE/eq8.png)

Some update algorithms require sampling, like Monte Carlo processes, what makes them inefficient for large datasets.
A VAE uses a uniquely defined objective. In the next chapters I will introduce their proposed loss function.

<br/>

![_config.yml]({{ site.baseurl }}/images/separator.png)

<br/>

{% include chapter.html name="Variational inference" %}

<br/>

For Bayesian inference we have seen already that calculating the posterior requires the knowledge of the evidence. Unfortunately, it is usually intractable:

![_config.yml]({{ site.baseurl }}/images/2023-7-6-VAE/eq6.png)

Either this integral has no closed-form solution due to the complexity of the data or the likelihood function is too complex due to nonlinear hidden layers.

Instead, variational inference will bring us closer to the solution. It is a method that approximates probability density functions through optimization. The basic approach is to create a family of possible densities and with a distance measure to find the density from this family that is the closest to the one we want to approximate.

![_config.yml]({{ site.baseurl }}/images/2023-7-6-VAE/eq9.png)

<br/>

Equation (2) is by itself not computable in our case because it involves calculating log(p(x)). The following calculation will show that:

![_config.yml]({{ site.baseurl }}/images/2023-7-6-VAE/eq10.png)

As we can see, that optimization problem contains the term log(p(x)) which makes it not computable.

<br/>

![_config.yml]({{ site.baseurl }}/images/separator.png)

<br/>

{% include chapter.html name="The Evidence Lower Bound" %}

<br/>

Even though the Kullback-Leibner Divergence is not computable we can use it after applying some tweaks.

![_config.yml]({{ site.baseurl }}/images/2023-7-6-VAE/eq11.png)

By adding the log(p(x)) term to the Kullback-Leibner Divergence we eliminate log(p(x)) from out objective.
With some further transformations we can rewrite that function to obtain an easier interpretation:

![_config.yml]({{ site.baseurl }}/images/2023-7-6-VAE/eq12.png)

The name originates from the following property:

![_config.yml]({{ site.baseurl }}/images/2023-7-6-VAE/eq13.png)

Below you can find an animated example where p is a normal density function and q a gamma density function. 
The plot on top is the graph of the ELBO and below a plot of p and q with varying values for its parameters. 
The maximum of log(p) is zero for every distribution and since the ELBO is bounded from above by log(p) the ELBO is therefore
bounded by zero from above.

<br/> 

![_config.yml]({{ site.baseurl }}/images/2023-7-6-VAE/animation.gif)

<br>
For complex neural network this integral might not be possible to compute. Therefore, we can use an estimate. In the next section I will show 
the estimator that Diederik P. Kingma and Max Welling proposed.

![_config.yml]({{ site.baseurl }}/images/separator.png)

<br/>

<br/>

{% include chapter.html name="Monte Carlo Estimator" %}

sec 2.4.2

<br/>

![_config.yml]({{ site.baseurl }}/images/separator.png)

<br>


{% include chapter.html name="Reparameterization Trick" %}

linear combination of RV: pi_1, ..., pi_n : pi_1 * P(X1) + ... + pi_n * P(X2)
mixture model but then all have differnt parameters


from script : VI where each data-case has a separate variational distribu-
tion, which is inefficient for large data-sets. The recognition model uses
one set of parameters to model the relation between input and latent
variables and as such is called “amortized inference”.

<br/>

![_config.yml]({{ site.baseurl }}/images/separator.png)


<br/>


{% include chapter.html name="The Gradient" %}

sec 2.3.

<br/>

![_config.yml]({{ site.baseurl }}/images/separator.png)

<br>

{% include chapter.html name="Sources" %}

- [Auto-Encoding Variational Bayes by Diederik P. Kingma, Max Welling](https://arxiv.org/pdf/1312.6114.pdf)
- [Variational Inference: A Review for Statisticians by David M. Blei](https://arxiv.org/pdf/1601.00670.pdf)
- [Image Super-Resolution With Deep Variational Autoencoders by Darius Chira, Ilian Haralampiev](https://arxiv.org/pdf/2203.09445.pdf)
- [An Introduction to Variational Autoencoders by Diederik P. Kingma, Max Welling](https://arxiv.org/pdf/1906.02691.pdf)



![_config.yml]({{ site.baseurl }}/images/separator.png)

